// +build !ignore_autogenerated

/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was autogenerated by deepcopy-gen. Do not edit it manually!

package api

import (
	v1 "k8s.io/kubernetes/pkg/apis/meta/v1"
	conversion "k8s.io/kubernetes/pkg/conversion"
	fields "k8s.io/kubernetes/pkg/fields"
	labels "k8s.io/kubernetes/pkg/labels"
	runtime "k8s.io/kubernetes/pkg/runtime"
	types "k8s.io/kubernetes/pkg/types"
	reflect "reflect"
)

func init() {
	SchemeBuilder.Register(RegisterDeepCopies)
}

// RegisterDeepCopies adds deep-copy functions to the given scheme. Public
// to allow building arbitrary schemes.
func RegisterDeepCopies(scheme *runtime.Scheme) error {
	return scheme.AddGeneratedDeepCopyFuncs(
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_AWSElasticBlockStoreVolumeSource, InType: reflect.TypeOf(&AWSElasticBlockStoreVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Affinity, InType: reflect.TypeOf(&Affinity{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_AttachedVolume, InType: reflect.TypeOf(&AttachedVolume{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_AvoidPods, InType: reflect.TypeOf(&AvoidPods{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_AzureDiskVolumeSource, InType: reflect.TypeOf(&AzureDiskVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_AzureFileVolumeSource, InType: reflect.TypeOf(&AzureFileVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Binding, InType: reflect.TypeOf(&Binding{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Capabilities, InType: reflect.TypeOf(&Capabilities{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_CephFSVolumeSource, InType: reflect.TypeOf(&CephFSVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_CinderVolumeSource, InType: reflect.TypeOf(&CinderVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ComponentCondition, InType: reflect.TypeOf(&ComponentCondition{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ComponentStatus, InType: reflect.TypeOf(&ComponentStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ComponentStatusList, InType: reflect.TypeOf(&ComponentStatusList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ConfigMap, InType: reflect.TypeOf(&ConfigMap{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ConfigMapEnvSource, InType: reflect.TypeOf(&ConfigMapEnvSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ConfigMapKeySelector, InType: reflect.TypeOf(&ConfigMapKeySelector{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ConfigMapList, InType: reflect.TypeOf(&ConfigMapList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ConfigMapVolumeSource, InType: reflect.TypeOf(&ConfigMapVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Container, InType: reflect.TypeOf(&Container{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ContainerImage, InType: reflect.TypeOf(&ContainerImage{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ContainerPort, InType: reflect.TypeOf(&ContainerPort{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ContainerState, InType: reflect.TypeOf(&ContainerState{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ContainerStateRunning, InType: reflect.TypeOf(&ContainerStateRunning{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ContainerStateTerminated, InType: reflect.TypeOf(&ContainerStateTerminated{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ContainerStateWaiting, InType: reflect.TypeOf(&ContainerStateWaiting{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ContainerStatus, InType: reflect.TypeOf(&ContainerStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ConversionError, InType: reflect.TypeOf(&ConversionError{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_DaemonEndpoint, InType: reflect.TypeOf(&DaemonEndpoint{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_DeleteOptions, InType: reflect.TypeOf(&DeleteOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_DownwardAPIVolumeFile, InType: reflect.TypeOf(&DownwardAPIVolumeFile{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_DownwardAPIVolumeSource, InType: reflect.TypeOf(&DownwardAPIVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_EmptyDirVolumeSource, InType: reflect.TypeOf(&EmptyDirVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_EndpointAddress, InType: reflect.TypeOf(&EndpointAddress{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_EndpointPort, InType: reflect.TypeOf(&EndpointPort{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_EndpointSubset, InType: reflect.TypeOf(&EndpointSubset{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Endpoints, InType: reflect.TypeOf(&Endpoints{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_EndpointsList, InType: reflect.TypeOf(&EndpointsList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_EnvFromSource, InType: reflect.TypeOf(&EnvFromSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_EnvVar, InType: reflect.TypeOf(&EnvVar{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_EnvVarSource, InType: reflect.TypeOf(&EnvVarSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Event, InType: reflect.TypeOf(&Event{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_EventList, InType: reflect.TypeOf(&EventList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_EventSource, InType: reflect.TypeOf(&EventSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ExecAction, InType: reflect.TypeOf(&ExecAction{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_FCVolumeSource, InType: reflect.TypeOf(&FCVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_FlexVolumeSource, InType: reflect.TypeOf(&FlexVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_FlockerVolumeSource, InType: reflect.TypeOf(&FlockerVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_GCEPersistentDiskVolumeSource, InType: reflect.TypeOf(&GCEPersistentDiskVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_GitRepoVolumeSource, InType: reflect.TypeOf(&GitRepoVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_GlusterfsVolumeSource, InType: reflect.TypeOf(&GlusterfsVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_HTTPGetAction, InType: reflect.TypeOf(&HTTPGetAction{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_HTTPHeader, InType: reflect.TypeOf(&HTTPHeader{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Handler, InType: reflect.TypeOf(&Handler{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_HostPathVolumeSource, InType: reflect.TypeOf(&HostPathVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ISCSIVolumeSource, InType: reflect.TypeOf(&ISCSIVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_KeyToPath, InType: reflect.TypeOf(&KeyToPath{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Lifecycle, InType: reflect.TypeOf(&Lifecycle{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_LimitRange, InType: reflect.TypeOf(&LimitRange{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_LimitRangeItem, InType: reflect.TypeOf(&LimitRangeItem{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_LimitRangeList, InType: reflect.TypeOf(&LimitRangeList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_LimitRangeSpec, InType: reflect.TypeOf(&LimitRangeSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_List, InType: reflect.TypeOf(&List{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ListOptions, InType: reflect.TypeOf(&ListOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_LoadBalancerIngress, InType: reflect.TypeOf(&LoadBalancerIngress{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_LoadBalancerStatus, InType: reflect.TypeOf(&LoadBalancerStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_LocalObjectReference, InType: reflect.TypeOf(&LocalObjectReference{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NFSVolumeSource, InType: reflect.TypeOf(&NFSVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Namespace, InType: reflect.TypeOf(&Namespace{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NamespaceList, InType: reflect.TypeOf(&NamespaceList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NamespaceSpec, InType: reflect.TypeOf(&NamespaceSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NamespaceStatus, InType: reflect.TypeOf(&NamespaceStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Node, InType: reflect.TypeOf(&Node{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NodeAddress, InType: reflect.TypeOf(&NodeAddress{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NodeAffinity, InType: reflect.TypeOf(&NodeAffinity{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NodeCondition, InType: reflect.TypeOf(&NodeCondition{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NodeDaemonEndpoints, InType: reflect.TypeOf(&NodeDaemonEndpoints{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NodeList, InType: reflect.TypeOf(&NodeList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NodeProxyOptions, InType: reflect.TypeOf(&NodeProxyOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NodeResources, InType: reflect.TypeOf(&NodeResources{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NodeSelector, InType: reflect.TypeOf(&NodeSelector{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NodeSelectorRequirement, InType: reflect.TypeOf(&NodeSelectorRequirement{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NodeSelectorTerm, InType: reflect.TypeOf(&NodeSelectorTerm{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NodeSpec, InType: reflect.TypeOf(&NodeSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NodeStatus, InType: reflect.TypeOf(&NodeStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NodeSystemInfo, InType: reflect.TypeOf(&NodeSystemInfo{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ObjectFieldSelector, InType: reflect.TypeOf(&ObjectFieldSelector{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ObjectMeta, InType: reflect.TypeOf(&ObjectMeta{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ObjectReference, InType: reflect.TypeOf(&ObjectReference{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PersistentVolume, InType: reflect.TypeOf(&PersistentVolume{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PersistentVolumeClaim, InType: reflect.TypeOf(&PersistentVolumeClaim{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PersistentVolumeClaimList, InType: reflect.TypeOf(&PersistentVolumeClaimList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PersistentVolumeClaimSpec, InType: reflect.TypeOf(&PersistentVolumeClaimSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PersistentVolumeClaimStatus, InType: reflect.TypeOf(&PersistentVolumeClaimStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PersistentVolumeClaimVolumeSource, InType: reflect.TypeOf(&PersistentVolumeClaimVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PersistentVolumeList, InType: reflect.TypeOf(&PersistentVolumeList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PersistentVolumeSource, InType: reflect.TypeOf(&PersistentVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PersistentVolumeSpec, InType: reflect.TypeOf(&PersistentVolumeSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PersistentVolumeStatus, InType: reflect.TypeOf(&PersistentVolumeStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PhotonPersistentDiskVolumeSource, InType: reflect.TypeOf(&PhotonPersistentDiskVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Pod, InType: reflect.TypeOf(&Pod{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodAffinity, InType: reflect.TypeOf(&PodAffinity{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodAffinityTerm, InType: reflect.TypeOf(&PodAffinityTerm{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodAntiAffinity, InType: reflect.TypeOf(&PodAntiAffinity{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodAttachOptions, InType: reflect.TypeOf(&PodAttachOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodCondition, InType: reflect.TypeOf(&PodCondition{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodExecOptions, InType: reflect.TypeOf(&PodExecOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodList, InType: reflect.TypeOf(&PodList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodLogOptions, InType: reflect.TypeOf(&PodLogOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodProxyOptions, InType: reflect.TypeOf(&PodProxyOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodSecurityContext, InType: reflect.TypeOf(&PodSecurityContext{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodSignature, InType: reflect.TypeOf(&PodSignature{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodSpec, InType: reflect.TypeOf(&PodSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodStatus, InType: reflect.TypeOf(&PodStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodStatusResult, InType: reflect.TypeOf(&PodStatusResult{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodTemplate, InType: reflect.TypeOf(&PodTemplate{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodTemplateList, InType: reflect.TypeOf(&PodTemplateList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodTemplateSpec, InType: reflect.TypeOf(&PodTemplateSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Preconditions, InType: reflect.TypeOf(&Preconditions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PreferAvoidPodsEntry, InType: reflect.TypeOf(&PreferAvoidPodsEntry{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PreferredSchedulingTerm, InType: reflect.TypeOf(&PreferredSchedulingTerm{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Probe, InType: reflect.TypeOf(&Probe{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_QuobyteVolumeSource, InType: reflect.TypeOf(&QuobyteVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_RBDVolumeSource, InType: reflect.TypeOf(&RBDVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_RangeAllocation, InType: reflect.TypeOf(&RangeAllocation{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ReplicationController, InType: reflect.TypeOf(&ReplicationController{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ReplicationControllerCondition, InType: reflect.TypeOf(&ReplicationControllerCondition{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ReplicationControllerList, InType: reflect.TypeOf(&ReplicationControllerList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ReplicationControllerSpec, InType: reflect.TypeOf(&ReplicationControllerSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ReplicationControllerStatus, InType: reflect.TypeOf(&ReplicationControllerStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ResourceFieldSelector, InType: reflect.TypeOf(&ResourceFieldSelector{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ResourceQuota, InType: reflect.TypeOf(&ResourceQuota{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ResourceQuotaList, InType: reflect.TypeOf(&ResourceQuotaList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ResourceQuotaSpec, InType: reflect.TypeOf(&ResourceQuotaSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ResourceQuotaStatus, InType: reflect.TypeOf(&ResourceQuotaStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ResourceRequirements, InType: reflect.TypeOf(&ResourceRequirements{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_SELinuxOptions, InType: reflect.TypeOf(&SELinuxOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Secret, InType: reflect.TypeOf(&Secret{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_SecretKeySelector, InType: reflect.TypeOf(&SecretKeySelector{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_SecretList, InType: reflect.TypeOf(&SecretList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_SecretVolumeSource, InType: reflect.TypeOf(&SecretVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_SecurityContext, InType: reflect.TypeOf(&SecurityContext{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_SerializedReference, InType: reflect.TypeOf(&SerializedReference{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Service, InType: reflect.TypeOf(&Service{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ServiceAccount, InType: reflect.TypeOf(&ServiceAccount{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ServiceAccountList, InType: reflect.TypeOf(&ServiceAccountList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ServiceList, InType: reflect.TypeOf(&ServiceList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ServicePort, InType: reflect.TypeOf(&ServicePort{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ServiceProxyOptions, InType: reflect.TypeOf(&ServiceProxyOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ServiceSpec, InType: reflect.TypeOf(&ServiceSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ServiceStatus, InType: reflect.TypeOf(&ServiceStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Sysctl, InType: reflect.TypeOf(&Sysctl{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_TCPSocketAction, InType: reflect.TypeOf(&TCPSocketAction{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Taint, InType: reflect.TypeOf(&Taint{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Toleration, InType: reflect.TypeOf(&Toleration{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Volume, InType: reflect.TypeOf(&Volume{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_VolumeMount, InType: reflect.TypeOf(&VolumeMount{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_VolumeSource, InType: reflect.TypeOf(&VolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_VsphereVirtualDiskVolumeSource, InType: reflect.TypeOf(&VsphereVirtualDiskVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_WeightedPodAffinityTerm, InType: reflect.TypeOf(&WeightedPodAffinityTerm{})},
	)
}

func DeepCopy_api_AWSElasticBlockStoreVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*AWSElasticBlockStoreVolumeSource)
		out := out.(*AWSElasticBlockStoreVolumeSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.VolumeID = in.VolumeID
		out.FSType = in.FSType
		out.Partition = in.Partition
		out.ReadOnly = in.ReadOnly
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_Affinity(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Affinity)
		out := out.(*Affinity)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.NodeAffinity != nil {
			in, out := &in.NodeAffinity, &out.NodeAffinity
			*out = new(NodeAffinity)
			if err := DeepCopy_api_NodeAffinity(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.NodeAffinity = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.PodAffinity != nil {
			in, out := &in.PodAffinity, &out.PodAffinity
			*out = new(PodAffinity)
			if err := DeepCopy_api_PodAffinity(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.PodAffinity = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.PodAntiAffinity != nil {
			in, out := &in.PodAntiAffinity, &out.PodAntiAffinity
			*out = new(PodAntiAffinity)
			if err := DeepCopy_api_PodAntiAffinity(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.PodAntiAffinity = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_AttachedVolume(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*AttachedVolume)
		out := out.(*AttachedVolume)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Name = in.Name
		out.DevicePath = in.DevicePath
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_AvoidPods(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*AvoidPods)
		out := out.(*AvoidPods)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.PreferAvoidPods != nil {
			in, out := &in.PreferAvoidPods, &out.PreferAvoidPods
			*out = make([]PreferAvoidPodsEntry, len(*in))
			for i := range *in {
				if err := DeepCopy_api_PreferAvoidPodsEntry(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.PreferAvoidPods = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_AzureDiskVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*AzureDiskVolumeSource)
		out := out.(*AzureDiskVolumeSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.DiskName = in.DiskName
		out.DataDiskURI = in.DataDiskURI
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.CachingMode != nil {
			in, out := &in.CachingMode, &out.CachingMode
			*out = new(AzureDataDiskCachingMode)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.CachingMode = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.FSType != nil {
			in, out := &in.FSType, &out.FSType
			*out = new(string)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.FSType = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.ReadOnly != nil {
			in, out := &in.ReadOnly, &out.ReadOnly
			*out = new(bool)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.ReadOnly = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_AzureFileVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*AzureFileVolumeSource)
		out := out.(*AzureFileVolumeSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.SecretName = in.SecretName
		out.ShareName = in.ShareName
		out.ReadOnly = in.ReadOnly
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_Binding(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Binding)
		out := out.(*Binding)
<<<<<<< HEAD
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		out.Target = in.Target
=======
>>>>>>> wip
		*out = *in
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
<<<<<<< HEAD
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_Capabilities(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Capabilities)
		out := out.(*Capabilities)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Add != nil {
			in, out := &in.Add, &out.Add
			*out = make([]Capability, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Add = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Drop != nil {
			in, out := &in.Drop, &out.Drop
			*out = make([]Capability, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Drop = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_CephFSVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*CephFSVolumeSource)
		out := out.(*CephFSVolumeSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Monitors != nil {
			in, out := &in.Monitors, &out.Monitors
			*out = make([]string, len(*in))
			copy(*out, *in)
<<<<<<< HEAD
		}
=======
<<<<<<< HEAD
		} else {
			out.Monitors = nil
		}
		out.Path = in.Path
		out.User = in.User
		out.SecretFile = in.SecretFile
=======
		}
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.SecretRef != nil {
			in, out := &in.SecretRef, &out.SecretRef
			*out = new(LocalObjectReference)
			**out = **in
<<<<<<< HEAD
		}
=======
<<<<<<< HEAD
		} else {
			out.SecretRef = nil
		}
		out.ReadOnly = in.ReadOnly
=======
		}
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_CinderVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*CinderVolumeSource)
		out := out.(*CinderVolumeSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.VolumeID = in.VolumeID
		out.FSType = in.FSType
		out.ReadOnly = in.ReadOnly
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_ComponentCondition(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ComponentCondition)
		out := out.(*ComponentCondition)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Type = in.Type
		out.Status = in.Status
		out.Message = in.Message
		out.Error = in.Error
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_ComponentStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ComponentStatus)
		out := out.(*ComponentStatus)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if in.Conditions != nil {
			in, out := &in.Conditions, &out.Conditions
			*out = make([]ComponentCondition, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Conditions = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_ComponentStatusList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ComponentStatusList)
		out := out.(*ComponentStatusList)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]ComponentStatus, len(*in))
			for i := range *in {
				if err := DeepCopy_api_ComponentStatus(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Items = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_ConfigMap(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ConfigMap)
		out := out.(*ConfigMap)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if in.Data != nil {
			in, out := &in.Data, &out.Data
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Data = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_ConfigMapEnvSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ConfigMapEnvSource)
		out := out.(*ConfigMapEnvSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.LocalObjectReference = in.LocalObjectReference
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_ConfigMapKeySelector(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ConfigMapKeySelector)
		out := out.(*ConfigMapKeySelector)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.LocalObjectReference = in.LocalObjectReference
		out.Key = in.Key
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_ConfigMapList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ConfigMapList)
		out := out.(*ConfigMapList)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]ConfigMap, len(*in))
			for i := range *in {
				if err := DeepCopy_api_ConfigMap(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Items = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_ConfigMapVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ConfigMapVolumeSource)
		out := out.(*ConfigMapVolumeSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.LocalObjectReference = in.LocalObjectReference
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]KeyToPath, len(*in))
			for i := range *in {
				if err := DeepCopy_api_KeyToPath(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Items = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.DefaultMode != nil {
			in, out := &in.DefaultMode, &out.DefaultMode
			*out = new(int32)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.DefaultMode = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_Container(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Container)
		out := out.(*Container)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Name = in.Name
		out.Image = in.Image
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Command != nil {
			in, out := &in.Command, &out.Command
			*out = make([]string, len(*in))
			copy(*out, *in)
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Command = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Args != nil {
			in, out := &in.Args, &out.Args
			*out = make([]string, len(*in))
			copy(*out, *in)
<<<<<<< HEAD
		}
=======
<<<<<<< HEAD
		} else {
			out.Args = nil
		}
		out.WorkingDir = in.WorkingDir
=======
		}
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Ports != nil {
			in, out := &in.Ports, &out.Ports
			*out = make([]ContainerPort, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Ports = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.EnvFrom != nil {
			in, out := &in.EnvFrom, &out.EnvFrom
			*out = make([]EnvFromSource, len(*in))
			for i := range *in {
				if err := DeepCopy_api_EnvFromSource(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.EnvFrom = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Env != nil {
			in, out := &in.Env, &out.Env
			*out = make([]EnvVar, len(*in))
			for i := range *in {
				if err := DeepCopy_api_EnvVar(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Env = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if err := DeepCopy_api_ResourceRequirements(&in.Resources, &out.Resources, c); err != nil {
			return err
		}
		if in.VolumeMounts != nil {
			in, out := &in.VolumeMounts, &out.VolumeMounts
			*out = make([]VolumeMount, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.VolumeMounts = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.LivenessProbe != nil {
			in, out := &in.LivenessProbe, &out.LivenessProbe
			*out = new(Probe)
			if err := DeepCopy_api_Probe(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.LivenessProbe = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.ReadinessProbe != nil {
			in, out := &in.ReadinessProbe, &out.ReadinessProbe
			*out = new(Probe)
			if err := DeepCopy_api_Probe(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.ReadinessProbe = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Lifecycle != nil {
			in, out := &in.Lifecycle, &out.Lifecycle
			*out = new(Lifecycle)
			if err := DeepCopy_api_Lifecycle(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
		}
=======
<<<<<<< HEAD
		} else {
			out.Lifecycle = nil
		}
		out.TerminationMessagePath = in.TerminationMessagePath
		out.ImagePullPolicy = in.ImagePullPolicy
=======
		}
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.SecurityContext != nil {
			in, out := &in.SecurityContext, &out.SecurityContext
			*out = new(SecurityContext)
			if err := DeepCopy_api_SecurityContext(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
		}
=======
<<<<<<< HEAD
		} else {
			out.SecurityContext = nil
		}
		out.Stdin = in.Stdin
		out.StdinOnce = in.StdinOnce
		out.TTY = in.TTY
=======
		}
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_ContainerImage(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ContainerImage)
		out := out.(*ContainerImage)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Names != nil {
			in, out := &in.Names, &out.Names
			*out = make([]string, len(*in))
			copy(*out, *in)
<<<<<<< HEAD
		}
=======
<<<<<<< HEAD
		} else {
			out.Names = nil
		}
		out.SizeBytes = in.SizeBytes
=======
		}
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_ContainerPort(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ContainerPort)
		out := out.(*ContainerPort)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Name = in.Name
		out.HostPort = in.HostPort
		out.ContainerPort = in.ContainerPort
		out.Protocol = in.Protocol
		out.HostIP = in.HostIP
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_ContainerState(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ContainerState)
		out := out.(*ContainerState)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Waiting != nil {
			in, out := &in.Waiting, &out.Waiting
			*out = new(ContainerStateWaiting)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Waiting = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Running != nil {
			in, out := &in.Running, &out.Running
			*out = new(ContainerStateRunning)
			if err := DeepCopy_api_ContainerStateRunning(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Running = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Terminated != nil {
			in, out := &in.Terminated, &out.Terminated
			*out = new(ContainerStateTerminated)
			if err := DeepCopy_api_ContainerStateTerminated(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Terminated = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_ContainerStateRunning(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ContainerStateRunning)
		out := out.(*ContainerStateRunning)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		out.StartedAt = in.StartedAt.DeepCopy()
		return nil
	}
}

func DeepCopy_api_ContainerStateTerminated(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ContainerStateTerminated)
		out := out.(*ContainerStateTerminated)
<<<<<<< HEAD
		*out = *in
		out.StartedAt = in.StartedAt.DeepCopy()
		out.FinishedAt = in.FinishedAt.DeepCopy()
=======
<<<<<<< HEAD
		out.ExitCode = in.ExitCode
		out.Signal = in.Signal
		out.Reason = in.Reason
		out.Message = in.Message
		out.StartedAt = in.StartedAt.DeepCopy()
		out.FinishedAt = in.FinishedAt.DeepCopy()
		out.ContainerID = in.ContainerID
=======
		*out = *in
		out.StartedAt = in.StartedAt.DeepCopy()
		out.FinishedAt = in.FinishedAt.DeepCopy()
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_ContainerStateWaiting(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ContainerStateWaiting)
		out := out.(*ContainerStateWaiting)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Reason = in.Reason
		out.Message = in.Message
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_ContainerStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ContainerStatus)
		out := out.(*ContainerStatus)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Name = in.Name
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if err := DeepCopy_api_ContainerState(&in.State, &out.State, c); err != nil {
			return err
		}
		if err := DeepCopy_api_ContainerState(&in.LastTerminationState, &out.LastTerminationState, c); err != nil {
			return err
		}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		out.Ready = in.Ready
		out.RestartCount = in.RestartCount
		out.Image = in.Image
		out.ImageID = in.ImageID
		out.ContainerID = in.ContainerID
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_ConversionError(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ConversionError)
		out := out.(*ConversionError)
<<<<<<< HEAD
=======
<<<<<<< HEAD
		if in.In == nil {
			out.In = nil
		} else if newVal, err := c.DeepCopy(&in.In); err != nil {
			return err
		} else {
			out.In = *newVal.(*interface{})
		}
		if in.Out == nil {
			out.Out = nil
		} else if newVal, err := c.DeepCopy(&in.Out); err != nil {
			return err
		} else {
			out.Out = *newVal.(*interface{})
		}
		out.Message = in.Message
=======
>>>>>>> wip
		*out = *in
		// in.In is kind 'Interface'
		if in.In != nil {
			if newVal, err := c.DeepCopy(&in.In); err != nil {
				return err
			} else {
				out.In = *newVal.(*interface{})
			}
		}
		// in.Out is kind 'Interface'
		if in.Out != nil {
			if newVal, err := c.DeepCopy(&in.Out); err != nil {
				return err
			} else {
				out.Out = *newVal.(*interface{})
			}
		}
<<<<<<< HEAD
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_DaemonEndpoint(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*DaemonEndpoint)
		out := out.(*DaemonEndpoint)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Port = in.Port
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_DeleteOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*DeleteOptions)
		out := out.(*DeleteOptions)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.GracePeriodSeconds != nil {
			in, out := &in.GracePeriodSeconds, &out.GracePeriodSeconds
			*out = new(int64)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.GracePeriodSeconds = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Preconditions != nil {
			in, out := &in.Preconditions, &out.Preconditions
			*out = new(Preconditions)
			if err := DeepCopy_api_Preconditions(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Preconditions = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.OrphanDependents != nil {
			in, out := &in.OrphanDependents, &out.OrphanDependents
			*out = new(bool)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.OrphanDependents = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_DownwardAPIVolumeFile(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*DownwardAPIVolumeFile)
		out := out.(*DownwardAPIVolumeFile)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Path = in.Path
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.FieldRef != nil {
			in, out := &in.FieldRef, &out.FieldRef
			*out = new(ObjectFieldSelector)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.FieldRef = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.ResourceFieldRef != nil {
			in, out := &in.ResourceFieldRef, &out.ResourceFieldRef
			*out = new(ResourceFieldSelector)
			if err := DeepCopy_api_ResourceFieldSelector(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.ResourceFieldRef = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Mode != nil {
			in, out := &in.Mode, &out.Mode
			*out = new(int32)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Mode = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_DownwardAPIVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*DownwardAPIVolumeSource)
		out := out.(*DownwardAPIVolumeSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]DownwardAPIVolumeFile, len(*in))
			for i := range *in {
				if err := DeepCopy_api_DownwardAPIVolumeFile(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Items = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.DefaultMode != nil {
			in, out := &in.DefaultMode, &out.DefaultMode
			*out = new(int32)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.DefaultMode = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_EmptyDirVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EmptyDirVolumeSource)
		out := out.(*EmptyDirVolumeSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Medium = in.Medium
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_EndpointAddress(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EndpointAddress)
		out := out.(*EndpointAddress)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.IP = in.IP
		out.Hostname = in.Hostname
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.NodeName != nil {
			in, out := &in.NodeName, &out.NodeName
			*out = new(string)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.NodeName = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.TargetRef != nil {
			in, out := &in.TargetRef, &out.TargetRef
			*out = new(ObjectReference)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.TargetRef = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_EndpointPort(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EndpointPort)
		out := out.(*EndpointPort)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Name = in.Name
		out.Port = in.Port
		out.Protocol = in.Protocol
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_EndpointSubset(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EndpointSubset)
		out := out.(*EndpointSubset)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Addresses != nil {
			in, out := &in.Addresses, &out.Addresses
			*out = make([]EndpointAddress, len(*in))
			for i := range *in {
				if err := DeepCopy_api_EndpointAddress(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Addresses = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.NotReadyAddresses != nil {
			in, out := &in.NotReadyAddresses, &out.NotReadyAddresses
			*out = make([]EndpointAddress, len(*in))
			for i := range *in {
				if err := DeepCopy_api_EndpointAddress(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.NotReadyAddresses = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Ports != nil {
			in, out := &in.Ports, &out.Ports
			*out = make([]EndpointPort, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Ports = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_Endpoints(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Endpoints)
		out := out.(*Endpoints)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if in.Subsets != nil {
			in, out := &in.Subsets, &out.Subsets
			*out = make([]EndpointSubset, len(*in))
			for i := range *in {
				if err := DeepCopy_api_EndpointSubset(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Subsets = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_EndpointsList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EndpointsList)
		out := out.(*EndpointsList)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]Endpoints, len(*in))
			for i := range *in {
				if err := DeepCopy_api_Endpoints(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Items = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_EnvFromSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EnvFromSource)
		out := out.(*EnvFromSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Prefix = in.Prefix
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.ConfigMapRef != nil {
			in, out := &in.ConfigMapRef, &out.ConfigMapRef
			*out = new(ConfigMapEnvSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.ConfigMapRef = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_EnvVar(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EnvVar)
		out := out.(*EnvVar)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Name = in.Name
		out.Value = in.Value
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.ValueFrom != nil {
			in, out := &in.ValueFrom, &out.ValueFrom
			*out = new(EnvVarSource)
			if err := DeepCopy_api_EnvVarSource(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.ValueFrom = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_EnvVarSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EnvVarSource)
		out := out.(*EnvVarSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.FieldRef != nil {
			in, out := &in.FieldRef, &out.FieldRef
			*out = new(ObjectFieldSelector)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.FieldRef = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.ResourceFieldRef != nil {
			in, out := &in.ResourceFieldRef, &out.ResourceFieldRef
			*out = new(ResourceFieldSelector)
			if err := DeepCopy_api_ResourceFieldSelector(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.ResourceFieldRef = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.ConfigMapKeyRef != nil {
			in, out := &in.ConfigMapKeyRef, &out.ConfigMapKeyRef
			*out = new(ConfigMapKeySelector)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.ConfigMapKeyRef = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.SecretKeyRef != nil {
			in, out := &in.SecretKeyRef, &out.SecretKeyRef
			*out = new(SecretKeySelector)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.SecretKeyRef = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_Event(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Event)
		out := out.(*Event)
<<<<<<< HEAD
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		out.InvolvedObject = in.InvolvedObject
		out.Reason = in.Reason
		out.Message = in.Message
		out.Source = in.Source
		out.FirstTimestamp = in.FirstTimestamp.DeepCopy()
		out.LastTimestamp = in.LastTimestamp.DeepCopy()
		out.Count = in.Count
		out.Type = in.Type
=======
>>>>>>> wip
		*out = *in
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		out.FirstTimestamp = in.FirstTimestamp.DeepCopy()
		out.LastTimestamp = in.LastTimestamp.DeepCopy()
<<<<<<< HEAD
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_EventList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EventList)
		out := out.(*EventList)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]Event, len(*in))
			for i := range *in {
				if err := DeepCopy_api_Event(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Items = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_EventSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EventSource)
		out := out.(*EventSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Component = in.Component
		out.Host = in.Host
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_ExecAction(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ExecAction)
		out := out.(*ExecAction)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Command != nil {
			in, out := &in.Command, &out.Command
			*out = make([]string, len(*in))
			copy(*out, *in)
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Command = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_FCVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*FCVolumeSource)
		out := out.(*FCVolumeSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.TargetWWNs != nil {
			in, out := &in.TargetWWNs, &out.TargetWWNs
			*out = make([]string, len(*in))
			copy(*out, *in)
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.TargetWWNs = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Lun != nil {
			in, out := &in.Lun, &out.Lun
			*out = new(int32)
			**out = **in
<<<<<<< HEAD
		}
=======
<<<<<<< HEAD
		} else {
			out.Lun = nil
		}
		out.FSType = in.FSType
		out.ReadOnly = in.ReadOnly
=======
		}
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_FlexVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*FlexVolumeSource)
		out := out.(*FlexVolumeSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Driver = in.Driver
		out.FSType = in.FSType
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.SecretRef != nil {
			in, out := &in.SecretRef, &out.SecretRef
			*out = new(LocalObjectReference)
			**out = **in
<<<<<<< HEAD
		}
=======
<<<<<<< HEAD
		} else {
			out.SecretRef = nil
		}
		out.ReadOnly = in.ReadOnly
=======
		}
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Options != nil {
			in, out := &in.Options, &out.Options
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Options = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_FlockerVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*FlockerVolumeSource)
		out := out.(*FlockerVolumeSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.DatasetName = in.DatasetName
		out.DatasetUUID = in.DatasetUUID
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_GCEPersistentDiskVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*GCEPersistentDiskVolumeSource)
		out := out.(*GCEPersistentDiskVolumeSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.PDName = in.PDName
		out.FSType = in.FSType
		out.Partition = in.Partition
		out.ReadOnly = in.ReadOnly
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_GitRepoVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*GitRepoVolumeSource)
		out := out.(*GitRepoVolumeSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Repository = in.Repository
		out.Revision = in.Revision
		out.Directory = in.Directory
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_GlusterfsVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*GlusterfsVolumeSource)
		out := out.(*GlusterfsVolumeSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.EndpointsName = in.EndpointsName
		out.Path = in.Path
		out.ReadOnly = in.ReadOnly
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_HTTPGetAction(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*HTTPGetAction)
		out := out.(*HTTPGetAction)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Path = in.Path
		out.Port = in.Port
		out.Host = in.Host
		out.Scheme = in.Scheme
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.HTTPHeaders != nil {
			in, out := &in.HTTPHeaders, &out.HTTPHeaders
			*out = make([]HTTPHeader, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.HTTPHeaders = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_HTTPHeader(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*HTTPHeader)
		out := out.(*HTTPHeader)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Name = in.Name
		out.Value = in.Value
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_Handler(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Handler)
		out := out.(*Handler)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Exec != nil {
			in, out := &in.Exec, &out.Exec
			*out = new(ExecAction)
			if err := DeepCopy_api_ExecAction(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Exec = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.HTTPGet != nil {
			in, out := &in.HTTPGet, &out.HTTPGet
			*out = new(HTTPGetAction)
			if err := DeepCopy_api_HTTPGetAction(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.HTTPGet = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.TCPSocket != nil {
			in, out := &in.TCPSocket, &out.TCPSocket
			*out = new(TCPSocketAction)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.TCPSocket = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_HostPathVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*HostPathVolumeSource)
		out := out.(*HostPathVolumeSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Path = in.Path
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_ISCSIVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ISCSIVolumeSource)
		out := out.(*ISCSIVolumeSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TargetPortal = in.TargetPortal
		out.IQN = in.IQN
		out.Lun = in.Lun
		out.ISCSIInterface = in.ISCSIInterface
		out.FSType = in.FSType
		out.ReadOnly = in.ReadOnly
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_KeyToPath(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*KeyToPath)
		out := out.(*KeyToPath)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Key = in.Key
		out.Path = in.Path
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Mode != nil {
			in, out := &in.Mode, &out.Mode
			*out = new(int32)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Mode = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_Lifecycle(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Lifecycle)
		out := out.(*Lifecycle)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.PostStart != nil {
			in, out := &in.PostStart, &out.PostStart
			*out = new(Handler)
			if err := DeepCopy_api_Handler(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.PostStart = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.PreStop != nil {
			in, out := &in.PreStop, &out.PreStop
			*out = new(Handler)
			if err := DeepCopy_api_Handler(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.PreStop = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_LimitRange(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*LimitRange)
		out := out.(*LimitRange)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if err := DeepCopy_api_LimitRangeSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_LimitRangeItem(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*LimitRangeItem)
		out := out.(*LimitRangeItem)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Type = in.Type
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Max != nil {
			in, out := &in.Max, &out.Max
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Max = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Min != nil {
			in, out := &in.Min, &out.Min
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Min = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Default != nil {
			in, out := &in.Default, &out.Default
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Default = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.DefaultRequest != nil {
			in, out := &in.DefaultRequest, &out.DefaultRequest
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.DefaultRequest = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.MaxLimitRequestRatio != nil {
			in, out := &in.MaxLimitRequestRatio, &out.MaxLimitRequestRatio
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.MaxLimitRequestRatio = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_LimitRangeList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*LimitRangeList)
		out := out.(*LimitRangeList)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]LimitRange, len(*in))
			for i := range *in {
				if err := DeepCopy_api_LimitRange(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Items = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_LimitRangeSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*LimitRangeSpec)
		out := out.(*LimitRangeSpec)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Limits != nil {
			in, out := &in.Limits, &out.Limits
			*out = make([]LimitRangeItem, len(*in))
			for i := range *in {
				if err := DeepCopy_api_LimitRangeItem(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Limits = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_List(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*List)
		out := out.(*List)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]runtime.Object, len(*in))
			for i := range *in {
				if newVal, err := c.DeepCopy(&(*in)[i]); err != nil {
					return err
				} else {
					(*out)[i] = *newVal.(*runtime.Object)
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Items = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_ListOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ListOptions)
		out := out.(*ListOptions)
<<<<<<< HEAD
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		if in.LabelSelector == nil {
			out.LabelSelector = nil
		} else if newVal, err := c.DeepCopy(&in.LabelSelector); err != nil {
			return err
		} else {
			out.LabelSelector = *newVal.(*labels.Selector)
		}
		if in.FieldSelector == nil {
			out.FieldSelector = nil
		} else if newVal, err := c.DeepCopy(&in.FieldSelector); err != nil {
			return err
		} else {
			out.FieldSelector = *newVal.(*fields.Selector)
		}
		out.Watch = in.Watch
		out.ResourceVersion = in.ResourceVersion
=======
>>>>>>> wip
		*out = *in
		// in.LabelSelector is kind 'Interface'
		if in.LabelSelector != nil {
			if newVal, err := c.DeepCopy(&in.LabelSelector); err != nil {
				return err
			} else {
				out.LabelSelector = *newVal.(*labels.Selector)
			}
		}
		// in.FieldSelector is kind 'Interface'
		if in.FieldSelector != nil {
			if newVal, err := c.DeepCopy(&in.FieldSelector); err != nil {
				return err
			} else {
				out.FieldSelector = *newVal.(*fields.Selector)
			}
		}
<<<<<<< HEAD
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.TimeoutSeconds != nil {
			in, out := &in.TimeoutSeconds, &out.TimeoutSeconds
			*out = new(int64)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.TimeoutSeconds = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_LoadBalancerIngress(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*LoadBalancerIngress)
		out := out.(*LoadBalancerIngress)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.IP = in.IP
		out.Hostname = in.Hostname
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_LoadBalancerStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*LoadBalancerStatus)
		out := out.(*LoadBalancerStatus)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Ingress != nil {
			in, out := &in.Ingress, &out.Ingress
			*out = make([]LoadBalancerIngress, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Ingress = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_LocalObjectReference(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*LocalObjectReference)
		out := out.(*LocalObjectReference)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Name = in.Name
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_NFSVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NFSVolumeSource)
		out := out.(*NFSVolumeSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Server = in.Server
		out.Path = in.Path
		out.ReadOnly = in.ReadOnly
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_Namespace(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Namespace)
		out := out.(*Namespace)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if err := DeepCopy_api_NamespaceSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		out.Status = in.Status
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_NamespaceList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NamespaceList)
		out := out.(*NamespaceList)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]Namespace, len(*in))
			for i := range *in {
				if err := DeepCopy_api_Namespace(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Items = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_NamespaceSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NamespaceSpec)
		out := out.(*NamespaceSpec)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Finalizers != nil {
			in, out := &in.Finalizers, &out.Finalizers
			*out = make([]FinalizerName, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Finalizers = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_NamespaceStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NamespaceStatus)
		out := out.(*NamespaceStatus)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Phase = in.Phase
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_Node(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Node)
		out := out.(*Node)
<<<<<<< HEAD
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		out.Spec = in.Spec
=======
>>>>>>> wip
		*out = *in
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
<<<<<<< HEAD
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		if err := DeepCopy_api_NodeStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_NodeAddress(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeAddress)
		out := out.(*NodeAddress)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Type = in.Type
		out.Address = in.Address
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_NodeAffinity(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeAffinity)
		out := out.(*NodeAffinity)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.RequiredDuringSchedulingIgnoredDuringExecution != nil {
			in, out := &in.RequiredDuringSchedulingIgnoredDuringExecution, &out.RequiredDuringSchedulingIgnoredDuringExecution
			*out = new(NodeSelector)
			if err := DeepCopy_api_NodeSelector(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.RequiredDuringSchedulingIgnoredDuringExecution = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			in, out := &in.PreferredDuringSchedulingIgnoredDuringExecution, &out.PreferredDuringSchedulingIgnoredDuringExecution
			*out = make([]PreferredSchedulingTerm, len(*in))
			for i := range *in {
				if err := DeepCopy_api_PreferredSchedulingTerm(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.PreferredDuringSchedulingIgnoredDuringExecution = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_NodeCondition(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeCondition)
		out := out.(*NodeCondition)
<<<<<<< HEAD
		*out = *in
		out.LastHeartbeatTime = in.LastHeartbeatTime.DeepCopy()
		out.LastTransitionTime = in.LastTransitionTime.DeepCopy()
=======
<<<<<<< HEAD
		out.Type = in.Type
		out.Status = in.Status
		out.LastHeartbeatTime = in.LastHeartbeatTime.DeepCopy()
		out.LastTransitionTime = in.LastTransitionTime.DeepCopy()
		out.Reason = in.Reason
		out.Message = in.Message
=======
		*out = *in
		out.LastHeartbeatTime = in.LastHeartbeatTime.DeepCopy()
		out.LastTransitionTime = in.LastTransitionTime.DeepCopy()
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_NodeDaemonEndpoints(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeDaemonEndpoints)
		out := out.(*NodeDaemonEndpoints)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.KubeletEndpoint = in.KubeletEndpoint
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_NodeList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeList)
		out := out.(*NodeList)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]Node, len(*in))
			for i := range *in {
				if err := DeepCopy_api_Node(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Items = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_NodeProxyOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeProxyOptions)
		out := out.(*NodeProxyOptions)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		out.Path = in.Path
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_NodeResources(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeResources)
		out := out.(*NodeResources)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Capacity != nil {
			in, out := &in.Capacity, &out.Capacity
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Capacity = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_NodeSelector(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeSelector)
		out := out.(*NodeSelector)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.NodeSelectorTerms != nil {
			in, out := &in.NodeSelectorTerms, &out.NodeSelectorTerms
			*out = make([]NodeSelectorTerm, len(*in))
			for i := range *in {
				if err := DeepCopy_api_NodeSelectorTerm(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.NodeSelectorTerms = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_NodeSelectorRequirement(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeSelectorRequirement)
		out := out.(*NodeSelectorRequirement)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Key = in.Key
		out.Operator = in.Operator
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Values != nil {
			in, out := &in.Values, &out.Values
			*out = make([]string, len(*in))
			copy(*out, *in)
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Values = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_NodeSelectorTerm(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeSelectorTerm)
		out := out.(*NodeSelectorTerm)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.MatchExpressions != nil {
			in, out := &in.MatchExpressions, &out.MatchExpressions
			*out = make([]NodeSelectorRequirement, len(*in))
			for i := range *in {
				if err := DeepCopy_api_NodeSelectorRequirement(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.MatchExpressions = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_NodeSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeSpec)
		out := out.(*NodeSpec)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.PodCIDR = in.PodCIDR
		out.ExternalID = in.ExternalID
		out.ProviderID = in.ProviderID
		out.Unschedulable = in.Unschedulable
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_NodeStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeStatus)
		out := out.(*NodeStatus)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Capacity != nil {
			in, out := &in.Capacity, &out.Capacity
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Capacity = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Allocatable != nil {
			in, out := &in.Allocatable, &out.Allocatable
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
<<<<<<< HEAD
		}
=======
<<<<<<< HEAD
		} else {
			out.Allocatable = nil
		}
		out.Phase = in.Phase
=======
		}
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Conditions != nil {
			in, out := &in.Conditions, &out.Conditions
			*out = make([]NodeCondition, len(*in))
			for i := range *in {
				if err := DeepCopy_api_NodeCondition(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Conditions = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Addresses != nil {
			in, out := &in.Addresses, &out.Addresses
			*out = make([]NodeAddress, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
<<<<<<< HEAD
		}
=======
<<<<<<< HEAD
		} else {
			out.Addresses = nil
		}
		out.DaemonEndpoints = in.DaemonEndpoints
		out.NodeInfo = in.NodeInfo
=======
		}
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Images != nil {
			in, out := &in.Images, &out.Images
			*out = make([]ContainerImage, len(*in))
			for i := range *in {
				if err := DeepCopy_api_ContainerImage(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Images = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.VolumesInUse != nil {
			in, out := &in.VolumesInUse, &out.VolumesInUse
			*out = make([]UniqueVolumeName, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.VolumesInUse = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.VolumesAttached != nil {
			in, out := &in.VolumesAttached, &out.VolumesAttached
			*out = make([]AttachedVolume, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.VolumesAttached = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_NodeSystemInfo(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeSystemInfo)
		out := out.(*NodeSystemInfo)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.MachineID = in.MachineID
		out.SystemUUID = in.SystemUUID
		out.BootID = in.BootID
		out.KernelVersion = in.KernelVersion
		out.OSImage = in.OSImage
		out.ContainerRuntimeVersion = in.ContainerRuntimeVersion
		out.KubeletVersion = in.KubeletVersion
		out.KubeProxyVersion = in.KubeProxyVersion
		out.OperatingSystem = in.OperatingSystem
		out.Architecture = in.Architecture
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_ObjectFieldSelector(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ObjectFieldSelector)
		out := out.(*ObjectFieldSelector)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.APIVersion = in.APIVersion
		out.FieldPath = in.FieldPath
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_ObjectMeta(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ObjectMeta)
		out := out.(*ObjectMeta)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Name = in.Name
		out.GenerateName = in.GenerateName
		out.Namespace = in.Namespace
		out.SelfLink = in.SelfLink
		out.UID = in.UID
		out.ResourceVersion = in.ResourceVersion
		out.Generation = in.Generation
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		out.CreationTimestamp = in.CreationTimestamp.DeepCopy()
		if in.DeletionTimestamp != nil {
			in, out := &in.DeletionTimestamp, &out.DeletionTimestamp
			*out = new(v1.Time)
			**out = (*in).DeepCopy()
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.DeletionTimestamp = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.DeletionGracePeriodSeconds != nil {
			in, out := &in.DeletionGracePeriodSeconds, &out.DeletionGracePeriodSeconds
			*out = new(int64)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.DeletionGracePeriodSeconds = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Labels != nil {
			in, out := &in.Labels, &out.Labels
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Labels = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Annotations != nil {
			in, out := &in.Annotations, &out.Annotations
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Annotations = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.OwnerReferences != nil {
			in, out := &in.OwnerReferences, &out.OwnerReferences
			*out = make([]v1.OwnerReference, len(*in))
			for i := range *in {
				if err := v1.DeepCopy_v1_OwnerReference(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.OwnerReferences = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Finalizers != nil {
			in, out := &in.Finalizers, &out.Finalizers
			*out = make([]string, len(*in))
			copy(*out, *in)
<<<<<<< HEAD
		}
=======
<<<<<<< HEAD
		} else {
			out.Finalizers = nil
		}
		out.ClusterName = in.ClusterName
=======
		}
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_ObjectReference(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ObjectReference)
		out := out.(*ObjectReference)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Kind = in.Kind
		out.Namespace = in.Namespace
		out.Name = in.Name
		out.UID = in.UID
		out.APIVersion = in.APIVersion
		out.ResourceVersion = in.ResourceVersion
		out.FieldPath = in.FieldPath
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_PersistentVolume(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolume)
		out := out.(*PersistentVolume)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if err := DeepCopy_api_PersistentVolumeSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		out.Status = in.Status
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_PersistentVolumeClaim(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeClaim)
		out := out.(*PersistentVolumeClaim)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if err := DeepCopy_api_PersistentVolumeClaimSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		if err := DeepCopy_api_PersistentVolumeClaimStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_PersistentVolumeClaimList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeClaimList)
		out := out.(*PersistentVolumeClaimList)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]PersistentVolumeClaim, len(*in))
			for i := range *in {
				if err := DeepCopy_api_PersistentVolumeClaim(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Items = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_PersistentVolumeClaimSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeClaimSpec)
		out := out.(*PersistentVolumeClaimSpec)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.AccessModes != nil {
			in, out := &in.AccessModes, &out.AccessModes
			*out = make([]PersistentVolumeAccessMode, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.AccessModes = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Selector != nil {
			in, out := &in.Selector, &out.Selector
			*out = new(v1.LabelSelector)
			if err := v1.DeepCopy_v1_LabelSelector(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Selector = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if err := DeepCopy_api_ResourceRequirements(&in.Resources, &out.Resources, c); err != nil {
			return err
		}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		out.VolumeName = in.VolumeName
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_PersistentVolumeClaimStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeClaimStatus)
		out := out.(*PersistentVolumeClaimStatus)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Phase = in.Phase
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.AccessModes != nil {
			in, out := &in.AccessModes, &out.AccessModes
			*out = make([]PersistentVolumeAccessMode, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.AccessModes = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Capacity != nil {
			in, out := &in.Capacity, &out.Capacity
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Capacity = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_PersistentVolumeClaimVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeClaimVolumeSource)
		out := out.(*PersistentVolumeClaimVolumeSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.ClaimName = in.ClaimName
		out.ReadOnly = in.ReadOnly
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_PersistentVolumeList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeList)
		out := out.(*PersistentVolumeList)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]PersistentVolume, len(*in))
			for i := range *in {
				if err := DeepCopy_api_PersistentVolume(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Items = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_PersistentVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeSource)
		out := out.(*PersistentVolumeSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.GCEPersistentDisk != nil {
			in, out := &in.GCEPersistentDisk, &out.GCEPersistentDisk
			*out = new(GCEPersistentDiskVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.GCEPersistentDisk = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.AWSElasticBlockStore != nil {
			in, out := &in.AWSElasticBlockStore, &out.AWSElasticBlockStore
			*out = new(AWSElasticBlockStoreVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.AWSElasticBlockStore = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.HostPath != nil {
			in, out := &in.HostPath, &out.HostPath
			*out = new(HostPathVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.HostPath = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Glusterfs != nil {
			in, out := &in.Glusterfs, &out.Glusterfs
			*out = new(GlusterfsVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Glusterfs = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.NFS != nil {
			in, out := &in.NFS, &out.NFS
			*out = new(NFSVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.NFS = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.RBD != nil {
			in, out := &in.RBD, &out.RBD
			*out = new(RBDVolumeSource)
			if err := DeepCopy_api_RBDVolumeSource(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.RBD = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Quobyte != nil {
			in, out := &in.Quobyte, &out.Quobyte
			*out = new(QuobyteVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Quobyte = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.ISCSI != nil {
			in, out := &in.ISCSI, &out.ISCSI
			*out = new(ISCSIVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.ISCSI = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.FlexVolume != nil {
			in, out := &in.FlexVolume, &out.FlexVolume
			*out = new(FlexVolumeSource)
			if err := DeepCopy_api_FlexVolumeSource(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.FlexVolume = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Cinder != nil {
			in, out := &in.Cinder, &out.Cinder
			*out = new(CinderVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Cinder = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.CephFS != nil {
			in, out := &in.CephFS, &out.CephFS
			*out = new(CephFSVolumeSource)
			if err := DeepCopy_api_CephFSVolumeSource(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.CephFS = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.FC != nil {
			in, out := &in.FC, &out.FC
			*out = new(FCVolumeSource)
			if err := DeepCopy_api_FCVolumeSource(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.FC = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Flocker != nil {
			in, out := &in.Flocker, &out.Flocker
			*out = new(FlockerVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Flocker = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.AzureFile != nil {
			in, out := &in.AzureFile, &out.AzureFile
			*out = new(AzureFileVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.AzureFile = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.VsphereVolume != nil {
			in, out := &in.VsphereVolume, &out.VsphereVolume
			*out = new(VsphereVirtualDiskVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.VsphereVolume = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.AzureDisk != nil {
			in, out := &in.AzureDisk, &out.AzureDisk
			*out = new(AzureDiskVolumeSource)
			if err := DeepCopy_api_AzureDiskVolumeSource(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.AzureDisk = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.PhotonPersistentDisk != nil {
			in, out := &in.PhotonPersistentDisk, &out.PhotonPersistentDisk
			*out = new(PhotonPersistentDiskVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.PhotonPersistentDisk = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_PersistentVolumeSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeSpec)
		out := out.(*PersistentVolumeSpec)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Capacity != nil {
			in, out := &in.Capacity, &out.Capacity
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Capacity = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if err := DeepCopy_api_PersistentVolumeSource(&in.PersistentVolumeSource, &out.PersistentVolumeSource, c); err != nil {
			return err
		}
		if in.AccessModes != nil {
			in, out := &in.AccessModes, &out.AccessModes
			*out = make([]PersistentVolumeAccessMode, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.AccessModes = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.ClaimRef != nil {
			in, out := &in.ClaimRef, &out.ClaimRef
			*out = new(ObjectReference)
			**out = **in
<<<<<<< HEAD
		}
=======
<<<<<<< HEAD
		} else {
			out.ClaimRef = nil
		}
		out.PersistentVolumeReclaimPolicy = in.PersistentVolumeReclaimPolicy
=======
		}
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_PersistentVolumeStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeStatus)
		out := out.(*PersistentVolumeStatus)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Phase = in.Phase
		out.Message = in.Message
		out.Reason = in.Reason
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_PhotonPersistentDiskVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PhotonPersistentDiskVolumeSource)
		out := out.(*PhotonPersistentDiskVolumeSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.PdID = in.PdID
		out.FSType = in.FSType
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_Pod(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Pod)
		out := out.(*Pod)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if err := DeepCopy_api_PodSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		if err := DeepCopy_api_PodStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_PodAffinity(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodAffinity)
		out := out.(*PodAffinity)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.RequiredDuringSchedulingIgnoredDuringExecution != nil {
			in, out := &in.RequiredDuringSchedulingIgnoredDuringExecution, &out.RequiredDuringSchedulingIgnoredDuringExecution
			*out = make([]PodAffinityTerm, len(*in))
			for i := range *in {
				if err := DeepCopy_api_PodAffinityTerm(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.RequiredDuringSchedulingIgnoredDuringExecution = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			in, out := &in.PreferredDuringSchedulingIgnoredDuringExecution, &out.PreferredDuringSchedulingIgnoredDuringExecution
			*out = make([]WeightedPodAffinityTerm, len(*in))
			for i := range *in {
				if err := DeepCopy_api_WeightedPodAffinityTerm(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.PreferredDuringSchedulingIgnoredDuringExecution = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_PodAffinityTerm(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodAffinityTerm)
		out := out.(*PodAffinityTerm)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.LabelSelector != nil {
			in, out := &in.LabelSelector, &out.LabelSelector
			*out = new(v1.LabelSelector)
			if err := v1.DeepCopy_v1_LabelSelector(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.LabelSelector = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Namespaces != nil {
			in, out := &in.Namespaces, &out.Namespaces
			*out = make([]string, len(*in))
			copy(*out, *in)
<<<<<<< HEAD
		}
=======
<<<<<<< HEAD
		} else {
			out.Namespaces = nil
		}
		out.TopologyKey = in.TopologyKey
=======
		}
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_PodAntiAffinity(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodAntiAffinity)
		out := out.(*PodAntiAffinity)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.RequiredDuringSchedulingIgnoredDuringExecution != nil {
			in, out := &in.RequiredDuringSchedulingIgnoredDuringExecution, &out.RequiredDuringSchedulingIgnoredDuringExecution
			*out = make([]PodAffinityTerm, len(*in))
			for i := range *in {
				if err := DeepCopy_api_PodAffinityTerm(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.RequiredDuringSchedulingIgnoredDuringExecution = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			in, out := &in.PreferredDuringSchedulingIgnoredDuringExecution, &out.PreferredDuringSchedulingIgnoredDuringExecution
			*out = make([]WeightedPodAffinityTerm, len(*in))
			for i := range *in {
				if err := DeepCopy_api_WeightedPodAffinityTerm(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.PreferredDuringSchedulingIgnoredDuringExecution = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_PodAttachOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodAttachOptions)
		out := out.(*PodAttachOptions)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		out.Stdin = in.Stdin
		out.Stdout = in.Stdout
		out.Stderr = in.Stderr
		out.TTY = in.TTY
		out.Container = in.Container
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_PodCondition(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodCondition)
		out := out.(*PodCondition)
<<<<<<< HEAD
		*out = *in
		out.LastProbeTime = in.LastProbeTime.DeepCopy()
		out.LastTransitionTime = in.LastTransitionTime.DeepCopy()
=======
<<<<<<< HEAD
		out.Type = in.Type
		out.Status = in.Status
		out.LastProbeTime = in.LastProbeTime.DeepCopy()
		out.LastTransitionTime = in.LastTransitionTime.DeepCopy()
		out.Reason = in.Reason
		out.Message = in.Message
=======
		*out = *in
		out.LastProbeTime = in.LastProbeTime.DeepCopy()
		out.LastTransitionTime = in.LastTransitionTime.DeepCopy()
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_PodExecOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodExecOptions)
		out := out.(*PodExecOptions)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		out.Stdin = in.Stdin
		out.Stdout = in.Stdout
		out.Stderr = in.Stderr
		out.TTY = in.TTY
		out.Container = in.Container
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Command != nil {
			in, out := &in.Command, &out.Command
			*out = make([]string, len(*in))
			copy(*out, *in)
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Command = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_PodList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodList)
		out := out.(*PodList)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]Pod, len(*in))
			for i := range *in {
				if err := DeepCopy_api_Pod(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Items = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_PodLogOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodLogOptions)
		out := out.(*PodLogOptions)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		out.Container = in.Container
		out.Follow = in.Follow
		out.Previous = in.Previous
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.SinceSeconds != nil {
			in, out := &in.SinceSeconds, &out.SinceSeconds
			*out = new(int64)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.SinceSeconds = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.SinceTime != nil {
			in, out := &in.SinceTime, &out.SinceTime
			*out = new(v1.Time)
			**out = (*in).DeepCopy()
<<<<<<< HEAD
		}
=======
<<<<<<< HEAD
		} else {
			out.SinceTime = nil
		}
		out.Timestamps = in.Timestamps
=======
		}
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.TailLines != nil {
			in, out := &in.TailLines, &out.TailLines
			*out = new(int64)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.TailLines = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.LimitBytes != nil {
			in, out := &in.LimitBytes, &out.LimitBytes
			*out = new(int64)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.LimitBytes = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_PodProxyOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodProxyOptions)
		out := out.(*PodProxyOptions)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		out.Path = in.Path
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_PodSecurityContext(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodSecurityContext)
		out := out.(*PodSecurityContext)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.HostNetwork = in.HostNetwork
		out.HostPID = in.HostPID
		out.HostIPC = in.HostIPC
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.SELinuxOptions != nil {
			in, out := &in.SELinuxOptions, &out.SELinuxOptions
			*out = new(SELinuxOptions)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.SELinuxOptions = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.RunAsUser != nil {
			in, out := &in.RunAsUser, &out.RunAsUser
			*out = new(int64)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.RunAsUser = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.RunAsNonRoot != nil {
			in, out := &in.RunAsNonRoot, &out.RunAsNonRoot
			*out = new(bool)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.RunAsNonRoot = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.SupplementalGroups != nil {
			in, out := &in.SupplementalGroups, &out.SupplementalGroups
			*out = make([]int64, len(*in))
			copy(*out, *in)
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.SupplementalGroups = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.FSGroup != nil {
			in, out := &in.FSGroup, &out.FSGroup
			*out = new(int64)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.FSGroup = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_PodSignature(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodSignature)
		out := out.(*PodSignature)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.PodController != nil {
			in, out := &in.PodController, &out.PodController
			*out = new(v1.OwnerReference)
			if err := v1.DeepCopy_v1_OwnerReference(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.PodController = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_PodSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodSpec)
		out := out.(*PodSpec)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Volumes != nil {
			in, out := &in.Volumes, &out.Volumes
			*out = make([]Volume, len(*in))
			for i := range *in {
				if err := DeepCopy_api_Volume(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Volumes = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.InitContainers != nil {
			in, out := &in.InitContainers, &out.InitContainers
			*out = make([]Container, len(*in))
			for i := range *in {
				if err := DeepCopy_api_Container(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.InitContainers = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Containers != nil {
			in, out := &in.Containers, &out.Containers
			*out = make([]Container, len(*in))
			for i := range *in {
				if err := DeepCopy_api_Container(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
		}
=======
<<<<<<< HEAD
		} else {
			out.Containers = nil
		}
		out.RestartPolicy = in.RestartPolicy
=======
		}
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.TerminationGracePeriodSeconds != nil {
			in, out := &in.TerminationGracePeriodSeconds, &out.TerminationGracePeriodSeconds
			*out = new(int64)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.TerminationGracePeriodSeconds = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.ActiveDeadlineSeconds != nil {
			in, out := &in.ActiveDeadlineSeconds, &out.ActiveDeadlineSeconds
			*out = new(int64)
			**out = **in
<<<<<<< HEAD
		}
=======
<<<<<<< HEAD
		} else {
			out.ActiveDeadlineSeconds = nil
		}
		out.DNSPolicy = in.DNSPolicy
=======
		}
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.NodeSelector != nil {
			in, out := &in.NodeSelector, &out.NodeSelector
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
<<<<<<< HEAD
		}
=======
<<<<<<< HEAD
		} else {
			out.NodeSelector = nil
		}
		out.ServiceAccountName = in.ServiceAccountName
		out.NodeName = in.NodeName
=======
		}
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.SecurityContext != nil {
			in, out := &in.SecurityContext, &out.SecurityContext
			*out = new(PodSecurityContext)
			if err := DeepCopy_api_PodSecurityContext(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.SecurityContext = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.ImagePullSecrets != nil {
			in, out := &in.ImagePullSecrets, &out.ImagePullSecrets
			*out = make([]LocalObjectReference, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
<<<<<<< HEAD
		}
=======
<<<<<<< HEAD
		} else {
			out.ImagePullSecrets = nil
		}
		out.Hostname = in.Hostname
		out.Subdomain = in.Subdomain
=======
		}
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Affinity != nil {
			in, out := &in.Affinity, &out.Affinity
			*out = new(Affinity)
			if err := DeepCopy_api_Affinity(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Affinity = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_PodStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodStatus)
		out := out.(*PodStatus)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Phase = in.Phase
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Conditions != nil {
			in, out := &in.Conditions, &out.Conditions
			*out = make([]PodCondition, len(*in))
			for i := range *in {
				if err := DeepCopy_api_PodCondition(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
		}
=======
<<<<<<< HEAD
		} else {
			out.Conditions = nil
		}
		out.Message = in.Message
		out.Reason = in.Reason
		out.HostIP = in.HostIP
		out.PodIP = in.PodIP
=======
		}
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.StartTime != nil {
			in, out := &in.StartTime, &out.StartTime
			*out = new(v1.Time)
			**out = (*in).DeepCopy()
<<<<<<< HEAD
		}
=======
<<<<<<< HEAD
		} else {
			out.StartTime = nil
		}
		out.QOSClass = in.QOSClass
=======
		}
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.InitContainerStatuses != nil {
			in, out := &in.InitContainerStatuses, &out.InitContainerStatuses
			*out = make([]ContainerStatus, len(*in))
			for i := range *in {
				if err := DeepCopy_api_ContainerStatus(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.InitContainerStatuses = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.ContainerStatuses != nil {
			in, out := &in.ContainerStatuses, &out.ContainerStatuses
			*out = make([]ContainerStatus, len(*in))
			for i := range *in {
				if err := DeepCopy_api_ContainerStatus(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.ContainerStatuses = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_PodStatusResult(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodStatusResult)
		out := out.(*PodStatusResult)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if err := DeepCopy_api_PodStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_PodTemplate(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodTemplate)
		out := out.(*PodTemplate)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if err := DeepCopy_api_PodTemplateSpec(&in.Template, &out.Template, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_PodTemplateList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodTemplateList)
		out := out.(*PodTemplateList)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]PodTemplate, len(*in))
			for i := range *in {
				if err := DeepCopy_api_PodTemplate(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Items = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_PodTemplateSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodTemplateSpec)
		out := out.(*PodTemplateSpec)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if err := DeepCopy_api_PodSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_Preconditions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Preconditions)
		out := out.(*Preconditions)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.UID != nil {
			in, out := &in.UID, &out.UID
			*out = new(types.UID)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.UID = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_PreferAvoidPodsEntry(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PreferAvoidPodsEntry)
		out := out.(*PreferAvoidPodsEntry)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if err := DeepCopy_api_PodSignature(&in.PodSignature, &out.PodSignature, c); err != nil {
			return err
		}
		out.EvictionTime = in.EvictionTime.DeepCopy()
<<<<<<< HEAD
=======
<<<<<<< HEAD
		out.Reason = in.Reason
		out.Message = in.Message
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_PreferredSchedulingTerm(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PreferredSchedulingTerm)
		out := out.(*PreferredSchedulingTerm)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Weight = in.Weight
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if err := DeepCopy_api_NodeSelectorTerm(&in.Preference, &out.Preference, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_Probe(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Probe)
		out := out.(*Probe)
<<<<<<< HEAD
=======
<<<<<<< HEAD
		if err := DeepCopy_api_Handler(&in.Handler, &out.Handler, c); err != nil {
			return err
		}
		out.InitialDelaySeconds = in.InitialDelaySeconds
		out.TimeoutSeconds = in.TimeoutSeconds
		out.PeriodSeconds = in.PeriodSeconds
		out.SuccessThreshold = in.SuccessThreshold
		out.FailureThreshold = in.FailureThreshold
=======
>>>>>>> wip
		*out = *in
		if err := DeepCopy_api_Handler(&in.Handler, &out.Handler, c); err != nil {
			return err
		}
<<<<<<< HEAD
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_QuobyteVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*QuobyteVolumeSource)
		out := out.(*QuobyteVolumeSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Registry = in.Registry
		out.Volume = in.Volume
		out.ReadOnly = in.ReadOnly
		out.User = in.User
		out.Group = in.Group
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_RBDVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*RBDVolumeSource)
		out := out.(*RBDVolumeSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.CephMonitors != nil {
			in, out := &in.CephMonitors, &out.CephMonitors
			*out = make([]string, len(*in))
			copy(*out, *in)
<<<<<<< HEAD
		}
=======
<<<<<<< HEAD
		} else {
			out.CephMonitors = nil
		}
		out.RBDImage = in.RBDImage
		out.FSType = in.FSType
		out.RBDPool = in.RBDPool
		out.RadosUser = in.RadosUser
		out.Keyring = in.Keyring
=======
		}
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.SecretRef != nil {
			in, out := &in.SecretRef, &out.SecretRef
			*out = new(LocalObjectReference)
			**out = **in
<<<<<<< HEAD
		}
=======
<<<<<<< HEAD
		} else {
			out.SecretRef = nil
		}
		out.ReadOnly = in.ReadOnly
=======
		}
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_RangeAllocation(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*RangeAllocation)
		out := out.(*RangeAllocation)
<<<<<<< HEAD
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		out.Range = in.Range
=======
>>>>>>> wip
		*out = *in
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
<<<<<<< HEAD
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Data != nil {
			in, out := &in.Data, &out.Data
			*out = make([]byte, len(*in))
			copy(*out, *in)
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Data = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_ReplicationController(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ReplicationController)
		out := out.(*ReplicationController)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if err := DeepCopy_api_ReplicationControllerSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		if err := DeepCopy_api_ReplicationControllerStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_ReplicationControllerCondition(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ReplicationControllerCondition)
		out := out.(*ReplicationControllerCondition)
<<<<<<< HEAD
		*out = *in
		out.LastTransitionTime = in.LastTransitionTime.DeepCopy()
=======
<<<<<<< HEAD
		out.Type = in.Type
		out.Status = in.Status
		out.LastTransitionTime = in.LastTransitionTime.DeepCopy()
		out.Reason = in.Reason
		out.Message = in.Message
=======
		*out = *in
		out.LastTransitionTime = in.LastTransitionTime.DeepCopy()
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_ReplicationControllerList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ReplicationControllerList)
		out := out.(*ReplicationControllerList)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]ReplicationController, len(*in))
			for i := range *in {
				if err := DeepCopy_api_ReplicationController(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Items = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_ReplicationControllerSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ReplicationControllerSpec)
		out := out.(*ReplicationControllerSpec)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Replicas = in.Replicas
		out.MinReadySeconds = in.MinReadySeconds
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Selector != nil {
			in, out := &in.Selector, &out.Selector
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Selector = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Template != nil {
			in, out := &in.Template, &out.Template
			*out = new(PodTemplateSpec)
			if err := DeepCopy_api_PodTemplateSpec(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Template = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_ReplicationControllerStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ReplicationControllerStatus)
		out := out.(*ReplicationControllerStatus)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Replicas = in.Replicas
		out.FullyLabeledReplicas = in.FullyLabeledReplicas
		out.ReadyReplicas = in.ReadyReplicas
		out.AvailableReplicas = in.AvailableReplicas
		out.ObservedGeneration = in.ObservedGeneration
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Conditions != nil {
			in, out := &in.Conditions, &out.Conditions
			*out = make([]ReplicationControllerCondition, len(*in))
			for i := range *in {
				if err := DeepCopy_api_ReplicationControllerCondition(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Conditions = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_ResourceFieldSelector(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ResourceFieldSelector)
		out := out.(*ResourceFieldSelector)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.ContainerName = in.ContainerName
		out.Resource = in.Resource
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		out.Divisor = in.Divisor.DeepCopy()
		return nil
	}
}

func DeepCopy_api_ResourceQuota(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ResourceQuota)
		out := out.(*ResourceQuota)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if err := DeepCopy_api_ResourceQuotaSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		if err := DeepCopy_api_ResourceQuotaStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_ResourceQuotaList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ResourceQuotaList)
		out := out.(*ResourceQuotaList)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]ResourceQuota, len(*in))
			for i := range *in {
				if err := DeepCopy_api_ResourceQuota(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Items = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_ResourceQuotaSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ResourceQuotaSpec)
		out := out.(*ResourceQuotaSpec)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Hard != nil {
			in, out := &in.Hard, &out.Hard
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Hard = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Scopes != nil {
			in, out := &in.Scopes, &out.Scopes
			*out = make([]ResourceQuotaScope, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Scopes = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_ResourceQuotaStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ResourceQuotaStatus)
		out := out.(*ResourceQuotaStatus)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Hard != nil {
			in, out := &in.Hard, &out.Hard
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Hard = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Used != nil {
			in, out := &in.Used, &out.Used
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Used = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_ResourceRequirements(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ResourceRequirements)
		out := out.(*ResourceRequirements)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Limits != nil {
			in, out := &in.Limits, &out.Limits
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Limits = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Requests != nil {
			in, out := &in.Requests, &out.Requests
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Requests = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_SELinuxOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*SELinuxOptions)
		out := out.(*SELinuxOptions)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.User = in.User
		out.Role = in.Role
		out.Type = in.Type
		out.Level = in.Level
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_Secret(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Secret)
		out := out.(*Secret)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if in.Data != nil {
			in, out := &in.Data, &out.Data
			*out = make(map[string][]byte)
			for key, val := range *in {
				if newVal, err := c.DeepCopy(&val); err != nil {
					return err
				} else {
					(*out)[key] = *newVal.(*[]byte)
				}
			}
<<<<<<< HEAD
		}
=======
<<<<<<< HEAD
		} else {
			out.Data = nil
		}
		out.Type = in.Type
=======
		}
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_SecretKeySelector(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*SecretKeySelector)
		out := out.(*SecretKeySelector)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.LocalObjectReference = in.LocalObjectReference
		out.Key = in.Key
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_SecretList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*SecretList)
		out := out.(*SecretList)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]Secret, len(*in))
			for i := range *in {
				if err := DeepCopy_api_Secret(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Items = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_SecretVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*SecretVolumeSource)
		out := out.(*SecretVolumeSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.SecretName = in.SecretName
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]KeyToPath, len(*in))
			for i := range *in {
				if err := DeepCopy_api_KeyToPath(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Items = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.DefaultMode != nil {
			in, out := &in.DefaultMode, &out.DefaultMode
			*out = new(int32)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.DefaultMode = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_SecurityContext(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*SecurityContext)
		out := out.(*SecurityContext)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Capabilities != nil {
			in, out := &in.Capabilities, &out.Capabilities
			*out = new(Capabilities)
			if err := DeepCopy_api_Capabilities(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Capabilities = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Privileged != nil {
			in, out := &in.Privileged, &out.Privileged
			*out = new(bool)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Privileged = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.SELinuxOptions != nil {
			in, out := &in.SELinuxOptions, &out.SELinuxOptions
			*out = new(SELinuxOptions)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.SELinuxOptions = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.RunAsUser != nil {
			in, out := &in.RunAsUser, &out.RunAsUser
			*out = new(int64)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.RunAsUser = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.RunAsNonRoot != nil {
			in, out := &in.RunAsNonRoot, &out.RunAsNonRoot
			*out = new(bool)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.RunAsNonRoot = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.ReadOnlyRootFilesystem != nil {
			in, out := &in.ReadOnlyRootFilesystem, &out.ReadOnlyRootFilesystem
			*out = new(bool)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.ReadOnlyRootFilesystem = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_SerializedReference(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*SerializedReference)
		out := out.(*SerializedReference)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		out.Reference = in.Reference
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_Service(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Service)
		out := out.(*Service)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if err := DeepCopy_api_ServiceSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		if err := DeepCopy_api_ServiceStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_ServiceAccount(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ServiceAccount)
		out := out.(*ServiceAccount)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if in.Secrets != nil {
			in, out := &in.Secrets, &out.Secrets
			*out = make([]ObjectReference, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Secrets = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.ImagePullSecrets != nil {
			in, out := &in.ImagePullSecrets, &out.ImagePullSecrets
			*out = make([]LocalObjectReference, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.ImagePullSecrets = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_ServiceAccountList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ServiceAccountList)
		out := out.(*ServiceAccountList)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]ServiceAccount, len(*in))
			for i := range *in {
				if err := DeepCopy_api_ServiceAccount(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Items = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_ServiceList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ServiceList)
		out := out.(*ServiceList)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]Service, len(*in))
			for i := range *in {
				if err := DeepCopy_api_Service(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Items = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_ServicePort(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ServicePort)
		out := out.(*ServicePort)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Name = in.Name
		out.Protocol = in.Protocol
		out.Port = in.Port
		out.TargetPort = in.TargetPort
		out.NodePort = in.NodePort
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_ServiceProxyOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ServiceProxyOptions)
		out := out.(*ServiceProxyOptions)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.TypeMeta = in.TypeMeta
		out.Path = in.Path
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_ServiceSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ServiceSpec)
		out := out.(*ServiceSpec)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Type = in.Type
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.Ports != nil {
			in, out := &in.Ports, &out.Ports
			*out = make([]ServicePort, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Ports = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Selector != nil {
			in, out := &in.Selector, &out.Selector
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
<<<<<<< HEAD
		}
=======
<<<<<<< HEAD
		} else {
			out.Selector = nil
		}
		out.ClusterIP = in.ClusterIP
		out.ExternalName = in.ExternalName
=======
		}
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.ExternalIPs != nil {
			in, out := &in.ExternalIPs, &out.ExternalIPs
			*out = make([]string, len(*in))
			copy(*out, *in)
<<<<<<< HEAD
		}
=======
<<<<<<< HEAD
		} else {
			out.ExternalIPs = nil
		}
		out.LoadBalancerIP = in.LoadBalancerIP
		out.SessionAffinity = in.SessionAffinity
=======
		}
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.LoadBalancerSourceRanges != nil {
			in, out := &in.LoadBalancerSourceRanges, &out.LoadBalancerSourceRanges
			*out = make([]string, len(*in))
			copy(*out, *in)
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.LoadBalancerSourceRanges = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_ServiceStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ServiceStatus)
		out := out.(*ServiceStatus)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if err := DeepCopy_api_LoadBalancerStatus(&in.LoadBalancer, &out.LoadBalancer, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_Sysctl(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Sysctl)
		out := out.(*Sysctl)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Name = in.Name
		out.Value = in.Value
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_TCPSocketAction(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*TCPSocketAction)
		out := out.(*TCPSocketAction)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Port = in.Port
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_Taint(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Taint)
		out := out.(*Taint)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Key = in.Key
		out.Value = in.Value
		out.Effect = in.Effect
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_Toleration(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Toleration)
		out := out.(*Toleration)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Key = in.Key
		out.Operator = in.Operator
		out.Value = in.Value
		out.Effect = in.Effect
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_Volume(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Volume)
		out := out.(*Volume)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Name = in.Name
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if err := DeepCopy_api_VolumeSource(&in.VolumeSource, &out.VolumeSource, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_VolumeMount(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*VolumeMount)
		out := out.(*VolumeMount)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Name = in.Name
		out.ReadOnly = in.ReadOnly
		out.MountPath = in.MountPath
		out.SubPath = in.SubPath
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_VolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*VolumeSource)
		out := out.(*VolumeSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if in.HostPath != nil {
			in, out := &in.HostPath, &out.HostPath
			*out = new(HostPathVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.HostPath = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.EmptyDir != nil {
			in, out := &in.EmptyDir, &out.EmptyDir
			*out = new(EmptyDirVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.EmptyDir = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.GCEPersistentDisk != nil {
			in, out := &in.GCEPersistentDisk, &out.GCEPersistentDisk
			*out = new(GCEPersistentDiskVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.GCEPersistentDisk = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.AWSElasticBlockStore != nil {
			in, out := &in.AWSElasticBlockStore, &out.AWSElasticBlockStore
			*out = new(AWSElasticBlockStoreVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.AWSElasticBlockStore = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.GitRepo != nil {
			in, out := &in.GitRepo, &out.GitRepo
			*out = new(GitRepoVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.GitRepo = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Secret != nil {
			in, out := &in.Secret, &out.Secret
			*out = new(SecretVolumeSource)
			if err := DeepCopy_api_SecretVolumeSource(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Secret = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.NFS != nil {
			in, out := &in.NFS, &out.NFS
			*out = new(NFSVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.NFS = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.ISCSI != nil {
			in, out := &in.ISCSI, &out.ISCSI
			*out = new(ISCSIVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.ISCSI = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Glusterfs != nil {
			in, out := &in.Glusterfs, &out.Glusterfs
			*out = new(GlusterfsVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Glusterfs = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.PersistentVolumeClaim != nil {
			in, out := &in.PersistentVolumeClaim, &out.PersistentVolumeClaim
			*out = new(PersistentVolumeClaimVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.PersistentVolumeClaim = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.RBD != nil {
			in, out := &in.RBD, &out.RBD
			*out = new(RBDVolumeSource)
			if err := DeepCopy_api_RBDVolumeSource(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.RBD = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Quobyte != nil {
			in, out := &in.Quobyte, &out.Quobyte
			*out = new(QuobyteVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Quobyte = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.FlexVolume != nil {
			in, out := &in.FlexVolume, &out.FlexVolume
			*out = new(FlexVolumeSource)
			if err := DeepCopy_api_FlexVolumeSource(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.FlexVolume = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Cinder != nil {
			in, out := &in.Cinder, &out.Cinder
			*out = new(CinderVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Cinder = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.CephFS != nil {
			in, out := &in.CephFS, &out.CephFS
			*out = new(CephFSVolumeSource)
			if err := DeepCopy_api_CephFSVolumeSource(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.CephFS = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.Flocker != nil {
			in, out := &in.Flocker, &out.Flocker
			*out = new(FlockerVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.Flocker = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.DownwardAPI != nil {
			in, out := &in.DownwardAPI, &out.DownwardAPI
			*out = new(DownwardAPIVolumeSource)
			if err := DeepCopy_api_DownwardAPIVolumeSource(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.DownwardAPI = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.FC != nil {
			in, out := &in.FC, &out.FC
			*out = new(FCVolumeSource)
			if err := DeepCopy_api_FCVolumeSource(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.FC = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.AzureFile != nil {
			in, out := &in.AzureFile, &out.AzureFile
			*out = new(AzureFileVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.AzureFile = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.ConfigMap != nil {
			in, out := &in.ConfigMap, &out.ConfigMap
			*out = new(ConfigMapVolumeSource)
			if err := DeepCopy_api_ConfigMapVolumeSource(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.ConfigMap = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.VsphereVolume != nil {
			in, out := &in.VsphereVolume, &out.VsphereVolume
			*out = new(VsphereVirtualDiskVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.VsphereVolume = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.AzureDisk != nil {
			in, out := &in.AzureDisk, &out.AzureDisk
			*out = new(AzureDiskVolumeSource)
			if err := DeepCopy_api_AzureDiskVolumeSource(*in, *out, c); err != nil {
				return err
			}
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.AzureDisk = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		if in.PhotonPersistentDisk != nil {
			in, out := &in.PhotonPersistentDisk, &out.PhotonPersistentDisk
			*out = new(PhotonPersistentDiskVolumeSource)
			**out = **in
<<<<<<< HEAD
=======
<<<<<<< HEAD
		} else {
			out.PhotonPersistentDisk = nil
=======
>>>>>>> e88b60f... wip
>>>>>>> wip
		}
		return nil
	}
}

func DeepCopy_api_VsphereVirtualDiskVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*VsphereVirtualDiskVolumeSource)
		out := out.(*VsphereVirtualDiskVolumeSource)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.VolumePath = in.VolumePath
		out.FSType = in.FSType
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		return nil
	}
}

func DeepCopy_api_WeightedPodAffinityTerm(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*WeightedPodAffinityTerm)
		out := out.(*WeightedPodAffinityTerm)
<<<<<<< HEAD
		*out = *in
=======
<<<<<<< HEAD
		out.Weight = in.Weight
=======
		*out = *in
>>>>>>> e88b60f... wip
>>>>>>> wip
		if err := DeepCopy_api_PodAffinityTerm(&in.PodAffinityTerm, &out.PodAffinityTerm, c); err != nil {
			return err
		}
		return nil
	}
}
